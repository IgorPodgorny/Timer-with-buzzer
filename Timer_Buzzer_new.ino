// ТАЙМЕР С 5 КНОПКАМИ И ЗВУКОВЫМ СИГНАЛОМ
// Кнопки: прибавить часы, убавить часы, прибавить минуты, убавить минуты, старт/стоп
// Кнопки со звуковым сигналом
// После того, как обратный отсчёт таймера запущен, настройки времени тоже можно менять

#include <TM1637.h> // подключаем библиотеку модуля TM1637
#define CLK 3 // определяем пины для подключения TM1637 к плате Arduino
#define DIO 4 // определяем пины для подключения TM1637 к плате Arduino
#define buttonPin 9 // определяем пин для подключения кнопки "увеличение часов"
#define buttonPin2 5// определяем пин для подключения кнопки "уменьшение часов"
#define buttonPin3 6 // определяем пин для подключения кнопки "увеличение минут"
#define buttonPin4 7 // определяем пин для подключения кнопки "уменьшение минут"
#define buttonPin5 8 // определяем пина для подключения кнопки "старт/стор"
#define buzzerPin 13 // определяем пин для подключения пьезоэлемента

unsigned long timing = 0; // переменная для времени, прошедшего с начала программы
unsigned long timingPipping = 0; // переменная для задержки пиканья буззера
unsigned long zeroBlinking = 0; // переменная для мигания нулей при окончании отсчёта таймера

int buttonHours = 0; // переменная для хранения состояния кнопки "часы"
int buttonMinutes = 0; // переменная для хранения состояния кнопки "минуты"
int buttonStartStop = 0; // переменная для хранения состояния кнопки "старт/стоп"
int counterHours = 0; // переменная для подсчёта нажатий на кнопку "часы"
int counterMinutes = 0; // переменная для подсчёта нажатий на кнопку "минуты"
int ARRAY[4]; // массив для хранения количества нажатий кнопок "часы" и "минуты"

boolean addHours = 0; // логическая переменная, которая хранит последнее состояние кнопки "прибавить часы"
boolean reduceHours = 0; // логическая переменная, которая хранит последнее состояние кнопки "убавить часы"
boolean addMinutes = 0; // логическая переменная, которая хранит последнее состояние кнопки "прибавить минуты"
boolean reduceMinutes = 0; // логическая переменная, которая хранит последнее состояние кнопки "убавить минуты"
boolean StartStopSwitcher = 0; // логическая переменная, которая хранит последнее состояние кнопки "старт/стоп"
boolean mode = 0; // логическая переменная, которая хранит текущий режим работы программы: настройка часов или обратный отсчёт/остановка таймера

unsigned long halfsec; // переменная для работы мигающего разделителя
boolean dots; // переменная для работы мигающего разделителя// переменная для работы мигающего разделителя

boolean stopPipping = 0; // переменная-флаг. Пока он false — пищим, когда true — не пищим и переходим в режим настройки
boolean blinking; // переменная для мигающих нулей после отключения таймера

TM1637 tm1637(CLK, DIO); // создаём объект класса TM1637, в качестве параметров используем номера пинов подключения дисплея к Ардуине

void setup() {
  Serial.begin(9600); // инициализация COM-порта
  tm1637.init(); // инициализация модуля TM1637
  tm1637.set(BRIGHT_TYPICAL); // устанавливаем яркость дисплея
}

void loop() {

  updateTimer (); // вызываем функцию обновления экрана
  Gyver_dots(); // вызываем функцию для моргания разделителя

  if (mode == 0) {
    // здесь будет выполняться настройка часов
    timeSetting ();
  }
  else {
    countdown (); // вызываем функцию обратного отсчёта
  }
}

//=====================ФУНКЦИИ=====================//

// ФУНКЦИЯ, КОТОРАЯ ОТВЕЧАЕТ ЗА НАСТРОЙКУ ЧАСОВ И МИНУТ

void timeSetting ()
{
  //buttonHours = digitalRead(buttonPin); // считываем значения с входа кнопки "увеличение часов" таймера

  if (digitalRead(buttonPin) == HIGH && addHours == 0) { // если кнопка нажата и переменная addHours (предыдущее состояние кнопки) = 0

    tone(buzzerPin, 2000, 100); // звук при нажатии на кнопку

    counterHours ++; // прибавляем единицу к переменной счётчика часов
    addHours = 1; // состояние кнопки меняется
    if (counterHours > 99) { // если значение > 99
      counterHours = 0; // то счётчик сбрасывается в ноль
    }
    ARRAY[0] = counterHours / 10; // записываем в 1 ячейку массива состояние кнопки "часы" (первая цифра перед запятой после деления на 10)
    ARRAY[1] = counterHours % 10; // записываем во 2 ячейку массива состояние кнопки "часы" (остаток от деления на 10)
    Serial.print("Часы: "); Serial.println(counterHours); // выводим в COM-порт состояние кнопки = переменной counterHours
  }
  if (digitalRead(buttonPin) == LOW && addHours == 1) { // если кнопка не нажата, т.е., мы её отпустили
    addHours = 0; // состояние кнопки "возвращается" к первоначальному сотсоянию
  }

  // ВТОРАЯ КНОПКА УМЕНЬШАЕТ ЗНАЧЕНИЕ ЧАСОВ НА ЕДИНИЦУ (действует также, как кнопка "addHours", только в минус)

  if (digitalRead(buttonPin2) == HIGH && reduceHours == 0) {
    tone(buzzerPin, 3000, 100); // звук при нажатии на кнопку
    counterHours--;
    reduceHours = 1;

    if (counterHours <= 0) { // если значение <= нулю, то уменьшение часов останавливаем
      counterHours = 0; // счётчик сбрасывается в ноль, если мы пытаем от нуля отнять единицу
    }
    ARRAY[0] = counterHours / 10; // записываем в 1 ячейку массива состояние кнопки "часы" (первая цифра перед запятой после деления на 10)
    ARRAY[1] = counterHours % 10; // записываем во 2 ячейку массива состояние кнопки "часы" (остаток от деления на 10)
    Serial.print("Часы: "); Serial.println(counterHours); // выводим в COM-порт состояние кнопки = переменной counterHours
  }
  if (digitalRead(buttonPin2) == LOW && reduceHours == 1) { // снова обработка того, что мы отпустили кнопку уменьшения часов
    reduceHours = 0; // состояние кнопки "возвращается" к первоначальному сотсоянию
  }
  if (addHours == 1 && reduceHours == 1) {  // при нажатии обеих кнопок сразу, значение на LED-дисплее обнуляется
    counterHours = 0;
  }

  // ВТОРАЯ ЧАСТЬ КОДА ДЛЯ УСТАНОВКИ МИНУТ (аналогично установке часов)

  //buttonMinutes = digitalRead(buttonPin3); // считываем значения с входа кнопки "увеличение минут" таймера

  if (digitalRead(buttonPin3) == HIGH && addMinutes == 0) { // если кнопка нажата и переменная addHours = 0
    tone(buzzerPin, 2000, 100); // звук при нажатии на кнопку
    counterMinutes ++; // прибавляем единицу к переменной счётчика
    addMinutes = 1; // состояние кнопки меняется

    if (counterMinutes > 60) { // если значение > 60, то счётчик сбрасывается на ноль
      counterMinutes = 0;
    }
    ARRAY[2] = counterMinutes / 10; // записываем в 1 ячейку массива состояние кнопки "часы" (первая цифра перед запятой после деления на 10)
    ARRAY[3] = counterMinutes % 10; // записываем во 2 ячейку массива состояние кнопки "часы" (остаток от деления на 10)
    Serial.print("Минуты: "); Serial.println(counterMinutes); // выводим в COM-порт состояние кнопки = переменной counterHours
  }
  if (digitalRead(buttonPin3) == LOW && addMinutes == 1) { // обработка того, что кнопка отпущена
    addMinutes = 0;
  }

  if (digitalRead(buttonPin4) == HIGH && reduceMinutes == 0) {
    tone(buzzerPin, 3000, 100); // звук при нажатии на кнопку
    counterMinutes --; // вторая кнопка уменьшает значение на единицу
    reduceMinutes = 1; // состояние кнопки изменилосб

    if (counterMinutes <= 0) { // если значение <= нулю, то сброс останавливаем
      counterMinutes = 0;
    }
    ARRAY[2] = counterMinutes / 10; // записываем в 1 ячейку массива состояние кнопки "часы" (первая цифра перед запятой после деления на 10)
    ARRAY[3] = counterMinutes % 10; // записываем во 2 ячейку массива состояние кнопки "часы" (остаток от деления на 10)
    Serial.print("Минуты: "); Serial.println(counterMinutes); // выводим в COM-порт состояние кнопки = переменной counterHours
  }

  if (digitalRead(buttonPin4) == LOW && reduceMinutes == 1) { // снова обработка того, что отпустили кнопку уменьшения минут
    reduceMinutes = 0;
  }

  if (addMinutes == 1 && reduceMinutes == 1) {
    counterMinutes = 0;
  }
  // ОБРАБОТКА КНОПКИ ПЕРЕКЛЮЧЕНИЯ РЕЖИМОВ НАСТРОЙКИ ЧАСОВ И ОБРАТНОГО ОТСЧЁТА

  if (digitalRead(buttonPin5) == HIGH && StartStopSwitcher == 0) {
    tone(buzzerPin, 5000, 100); // звук при нажатии на кнопку "старт"
    StartStopSwitcher = 1; // состояние кнопки изменилось
  }

  if (digitalRead(buttonPin5) == LOW && StartStopSwitcher == 1 ) { // снова обработка того, что отпустили кнопку уменьшения минут
    StartStopSwitcher = 0;
    if (counterHours > 0 || counterMinutes > 0) {
      mode = 1;
    }
  }
}

void updateTimer() // ФУНКЦИЯ ОБНОВЛЕНИЯ ЭКРАНА

{
  for (int i = 0; i < 4; i++) {
    tm1637.display(i, ARRAY[i]);
  }
}

void Gyver_dots() // ФУНКЦИЯ ДЛЯ МОРГАНИЯ РАЗДЕЛИТЕЛЯ ПО АЛЕКСУ ГАЙВЕРУ: http://alexgyver.ru/tm1637_display/http://alexgyver.ru/tm1637_display/

{
  if (millis() - halfsec > 500) {  // если прошло полсекунды
    halfsec = millis();            // сбросить таймер
    dots = !dots;                  // переключить точки
    if (dots) tm1637.point(0);     // выключить точки
    else tm1637.point(1);          // включить точки
  }
}

void countdown () // ФУНКЦИЯ ДЛЯ ВКЛЮЧЕНИЯ ОБРАТНОГО ОТСЧЁТА
{
  if (millis() - timing > 1000) { // задержка в 1 секунду
    timing = millis();

    if (counterMinutes > 0) { // если минут больше 0, то
      counterMinutes--; // отнимаем единицу от минут
    }
    else {

      if (counterHours > 0) { // проверяем, есть ли часы и, если есть, то...
        counterHours--; // отнимаем от часов единицу
        counterMinutes = 60; // минуты = 60
      }
      else {

        // ЗДЕСЬ БУДЕМ ПИЩАТЬ БУЗЗЕРОМ

        stopPipping = 0; // обнуляем переменную, чтобы после того, как остановили таймер, он пищал при достижении нуля

        byte frequency = 1; // переменная для изменения частоты буззера

        // буззер будет пищать, пока не нажмём на кнопку

        while (stopPipping == 0) {
          tm1637.point(0); // выключаем точки

          if (millis() - zeroBlinking > 500) {  // если прошло полсекунды
            zeroBlinking = millis();            // сбросить таймер
            blinking = !blinking;                  // переключить точки
            if (blinking) {
              for (int i = 0; i < 4; i++) {
                tm1637.display(i, 0);
              }
            }

            else {
              for (int i = 0; i < 4; i++) {
                tm1637.display(i, " ");
              }
            }
          }
          // НАСТРОЙКИ ЗВУКА БУЗЗЕРА И ЕГО ЗАПУСК

          /* ================================================================================

            // ВТОРОЙ ВАРИАНТ НАСТРОЙКИ ЗВУКА БУЗЗЕРА И ЕГО ЗАПУСКА С ПОМОЩЬЮ ПЕРЕМЕННОЙ

                   if (millis() - timingPipping > 300) {
                     tone(buzzerPin, frequency * 500, 200);
                     timingPipping = millis();
                     frequency++; // переменная frequency задаётся до начала цикла while
                     if (frequency > 8) {
                       frequency = 1;
                     }
                   }
          ================================================================================ */

          if ((millis() - timingPipping < 200)) {
            tone(buzzerPin, 2000, 200);
          }
          if (millis() - timingPipping > 200 && (millis() - timingPipping < 400)) {
            tone(buzzerPin, 3000, 200);

          }

          if (millis() - timingPipping > 400) {
            tone(buzzerPin, 4000, 200);
            timingPipping = millis();
          }
          if (digitalRead(buttonPin5) == HIGH && StartStopSwitcher == 0) { // если кнопка нажата и переменная StartStopSwitcher (предыдущее состояние кнопки) = 0
            StartStopSwitcher = 1; // состояние кнопки изменилось
          }

          if (digitalRead(buttonPin5) == LOW && StartStopSwitcher == 1) { // снова обработка того, что отпустили кнопку уменьшения минут

            tone(buzzerPin, 1000, 500); // звук при нажатии на кнопку "старт"

            StartStopSwitcher = 0;
            mode = 0; // меняем "флаг" на нулевой, то, есть переключаемся в режим настройки часов
            stopPipping = 1;
          }
        }
      }
    }
    ARRAY[0] = counterHours / 10; // записываем в 1 ячейку массива "часы" (первая цифра перед запятой после деления на 10)
    ARRAY[1] = counterHours % 10; // записываем во 2 ячейку массива "часы" (остаток деления на 10)
    ARRAY[2] = counterMinutes / 10; // записываем в 3 ячейку массива состояние кнопки "минуты" (первая цифра перед запятой после деления на 10)
    ARRAY[3] = counterMinutes % 10; // записываем в 3 ячейку массива состояние кнопки "минуты" (остаток деления на 10)
  }
  if (digitalRead(buttonPin5) == HIGH && StartStopSwitcher == 0) { // если кнопка нажата и переменная StartStopSwitcher (предыдущее состояние кнопки) = 0

    StartStopSwitcher = 1; // состояние кнопки изменилось
  }

  if (digitalRead(buttonPin5) == LOW && StartStopSwitcher == 1) { // снова обработка того, что отпустили кнопку уменьшения минут
    StartStopSwitcher = 0;
    tone(buzzerPin, 5000, 100); // звук при нажатии на кнопку "стоп" при работающем обратном отсчёте
    mode = 0; // меняем "флаг" на нулевой, то, есть переключаемся в режим настройки часов
  }
  timeSettingWhileCountdown (); // функция для того, чтобы настройку часов и минут можно было менять уже после того, как запущен обратный отсчёт таймера
}

// ФУНКЦИЯ ДЛЯ ТОГО, ЧТОБЫ НАСТРОЙКИ ВРЕМЕНИ МОЖНО БЫЛО МЕНЯТЬ УЖЕ ПОСЛЕ ТОГО, КАК ЗАПУЩЕН ОБРАТНЫЙ ОТСЧЁТ ТАЙМЕРА

void timeSettingWhileCountdown ()
{
  //buttonHours = digitalRead(buttonPin); // считываем значения с входа кнопки "увеличение часов" таймера

  if (digitalRead(buttonPin) == HIGH && addHours == 0) { // если кнопка нажата и переменная addHours (предыдущее состояние кнопки) = 0

    tone(buzzerPin, 2000, 100); // звук при нажатии на кнопку

    counterHours ++; // прибавляем единицу к переменной счётчика часов
    addHours = 1; // состояние кнопки меняется
    if (counterHours > 99) { // если значение > 99
      counterHours = 0; // то счётчик сбрасывается в ноль
    }
    ARRAY[0] = counterHours / 10; // записываем в 1 ячейку массива состояние кнопки "часы" (первая цифра перед запятой после деления на 10)
    ARRAY[1] = counterHours % 10; // записываем во 2 ячейку массива состояние кнопки "часы" (остаток от деления на 10)
    Serial.print("Часы: "); Serial.println(counterHours); // выводим в COM-порт состояние кнопки = переменной counterHours
  }
  if (digitalRead(buttonPin) == LOW && addHours == 1) { // если кнопка не нажата, т.е., мы её отпустили
    addHours = 0; // состояние кнопки "возвращается" к первоначальному сотсоянию
  }

  // ВТОРАЯ КНОПКА УМЕНЬШАЕТ ЗНАЧЕНИЕ ЧАСОВ НА ЕДИНИЦУ (действует также, как кнопка "addHours", только в минус)

  if (digitalRead(buttonPin2) == HIGH && reduceHours == 0) {
    tone(buzzerPin, 3000, 100); // звук при нажатии на кнопку
    counterHours--;
    reduceHours = 1;

    if (counterHours <= 0) { // если значение <= нулю, то уменьшение часов останавливаем
      counterHours = 0; // счётчик сбрасывается в ноль, если мы пытаем от нуля отнять единицу
    }
    ARRAY[0] = counterHours / 10; // записываем в 1 ячейку массива состояние кнопки "часы" (первая цифра перед запятой после деления на 10)
    ARRAY[1] = counterHours % 10; // записываем во 2 ячейку массива состояние кнопки "часы" (остаток от деления на 10)
    Serial.print("Часы: "); Serial.println(counterHours); // выводим в COM-порт состояние кнопки = переменной counterHours
  }
  if (digitalRead(buttonPin2) == LOW && reduceHours == 1) { // снова обработка того, что мы отпустили кнопку уменьшения часов
    reduceHours = 0; // состояние кнопки "возвращается" к первоначальному сотсоянию
  }
  if (addHours == 1 && reduceHours == 1) {  // при нажатии обеих кнопок сразу, значение на LED-дисплее обнуляется
    counterHours = 0;
  }

  // ВТОРАЯ ЧАСТЬ КОДА ДЛЯ УСТАНОВКИ МИНУТ (аналогично установке часов)

  //buttonMinutes = digitalRead(buttonPin3); // считываем значения с входа кнопки "увеличение минут" таймера

  if (digitalRead(buttonPin3) == HIGH && addMinutes == 0) { // если кнопка нажата и переменная addHours = 0
    tone(buzzerPin, 2000, 100); // звук при нажатии на кнопку
    counterMinutes ++; // прибавляем единицу к переменной счётчика
    addMinutes = 1; // состояние кнопки меняется

    if (counterMinutes > 60) { // если значение > 60, то счётчик сбрасывается на ноль
      counterMinutes = 0;
    }
    ARRAY[2] = counterMinutes / 10; // записываем в 1 ячейку массива состояние кнопки "часы" (первая цифра перед запятой после деления на 10)
    ARRAY[3] = counterMinutes % 10; // записываем во 2 ячейку массива состояние кнопки "часы" (остаток от деления на 10)
    Serial.print("Минуты: "); Serial.println(counterMinutes); // выводим в COM-порт состояние кнопки = переменной counterHours
  }
  if (digitalRead(buttonPin3) == LOW && addMinutes == 1) { // обработка того, что кнопка отпущена
    addMinutes = 0;
  }

  if (digitalRead(buttonPin4) == HIGH && reduceMinutes == 0) {
    tone(buzzerPin, 3000, 100); // звук при нажатии на кнопку
    counterMinutes --; // вторая кнопка уменьшает значение на единицу
    reduceMinutes = 1; // состояние кнопки изменилосб

    if (counterMinutes <= 0) { // если значение <= нулю, то сброс останавливаем
      counterMinutes = 0;
    }
    ARRAY[2] = counterMinutes / 10; // записываем в 1 ячейку массива состояние кнопки "часы" (первая цифра перед запятой после деления на 10)
    ARRAY[3] = counterMinutes % 10; // записываем во 2 ячейку массива состояние кнопки "часы" (остаток от деления на 10)
    Serial.print("Минуты: "); Serial.println(counterMinutes); // выводим в COM-порт состояние кнопки = переменной counterHours
  }

  if (digitalRead(buttonPin4) == LOW && reduceMinutes == 1) { // снова обработка того, что отпустили кнопку уменьшения минут
    reduceMinutes = 0;
  }

  if (addMinutes == 1 && reduceMinutes == 1) {
    counterMinutes = 0;
  }
}


